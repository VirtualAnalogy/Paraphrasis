/*  ==============================================================================    This file was auto-generated!    It contains the basic startup code for a Juce application.  ==============================================================================*/#include "PluginProcessor.h"#include "PluginEditor.h"//==============================================================================ParaphrasisAudioProcessor::ParaphrasisAudioProcessor(){    UserParams[MasterBypass]=0.0f;//default to not bypassed    //repeat for "OtherParams"    UIUpdateFlag=true;//Request UI update}ParaphrasisAudioProcessor::~ParaphrasisAudioProcessor(){}//==============================================================================const String ParaphrasisAudioProcessor::getName() const{    return JucePlugin_Name;}int ParaphrasisAudioProcessor::getNumParameters(){    return totalNumParam;}float ParaphrasisAudioProcessor::getParameter (int index){    //TODO: add cases for any special parameters    if (index >= 0  && index < totalNumParam)        return UserParams[index];    else        return 0.0f;//invalid index}void ParaphrasisAudioProcessor::setParameter (int index, float newValue){    //TODO: add cases for any special parameters    if (index >= 0 && index < totalNumParam)        UserParams[index] = newValue;    UIUpdateFlag = true;//Request UI update for when it did not come from  the primary editor}const String ParaphrasisAudioProcessor::getParameterName (int index){    switch (index)    {        case MasterBypass :            return "Master Bypass";        //OtherParams...        default :            return String::empty;    }}const String ParaphrasisAudioProcessor::getParameterText (int index){    if (index>=0 && index < totalNumParam)        return String (UserParams[index]); //return parameter value as string    else        return String::empty;}const String ParaphrasisAudioProcessor::getInputChannelName (int channelIndex) const{    return String (channelIndex + 1);}const String ParaphrasisAudioProcessor::getOutputChannelName (int channelIndex) const{    return String (channelIndex + 1);}bool ParaphrasisAudioProcessor::isInputChannelStereoPair (int index) const{    return true;}bool ParaphrasisAudioProcessor::isOutputChannelStereoPair (int index) const{    return true;}bool ParaphrasisAudioProcessor::acceptsMidi() const{#if JucePlugin_WantsMidiInput    return true;#else    return false;#endif}bool ParaphrasisAudioProcessor::producesMidi() const{#if JucePlugin_ProducesMidiOutput    return true;#else    return false;#endif}bool ParaphrasisAudioProcessor::silenceInProducesSilenceOut() const{    return false;}double ParaphrasisAudioProcessor::getTailLengthSeconds() const{    return 0.0;}int ParaphrasisAudioProcessor::getNumPrograms(){    return 0;}int ParaphrasisAudioProcessor::getCurrentProgram(){    return 0;}void ParaphrasisAudioProcessor::setCurrentProgram (int index){}const String ParaphrasisAudioProcessor::getProgramName (int index){    return String::empty;}void ParaphrasisAudioProcessor::changeProgramName (int index, const String& newName){}//==============================================================================void ParaphrasisAudioProcessor::prepareToPlay (double sampleRate, int samplesPerBlock){    // Use this method as the place to do any pre-playback    // initialisation that you need..}void ParaphrasisAudioProcessor::releaseResources(){    // When playback stops, you can use this as an opportunity to free up any    // spare memory, etc.}void ParaphrasisAudioProcessor::processBlock (AudioSampleBuffer& buffer, MidiBuffer& midiMessages){    // This is the place where you'd normally do the guts of your plugin's    // audio processing...    for (int channel = 0; channel < getNumInputChannels(); ++channel)    {        float* channelData = buffer.getWritePointer (channel);        // ..do something to the data...    }    // In case we have more outputs than inputs, we'll clear any output    // channels that didn't contain input data, (because these aren't    // guaranteed to be empty - they may contain garbage).    for (int i = getNumInputChannels(); i < getNumOutputChannels(); ++i)    {        buffer.clear (i, 0, buffer.getNumSamples() );    }}//==============================================================================bool ParaphrasisAudioProcessor::hasEditor() const{    return true; // (change this to false if you choose to not supply an editor)}AudioProcessorEditor* ParaphrasisAudioProcessor::createEditor(){    return new ParaphrasisAudioProcessorEditor (this);}//==============================================================================void ParaphrasisAudioProcessor::getStateInformation (MemoryBlock& destData){    // You should use this method to store your parameters in the memory block.    // You could do that either as raw data, or use the XML or ValueTree classes    // as intermediaries to make it easy to save and load complex data.    //Save UserParams/Data to file    XmlElement root ("Root");    XmlElement* el;    el = root.createNewChildElement ("Bypass");    el->addTextElement (String (UserParams[MasterBypass]) );    copyXmlToBinary (root,destData);}void ParaphrasisAudioProcessor::setStateInformation (const void* data, int sizeInBytes){    // You should use this method to restore your parameters from this memory block,    // whose contents will have been created by the getStateInformation() call.    //Load UserParams/Data from file    XmlElement* pRoot = getXmlFromBinary (data,sizeInBytes);    if (pRoot!=NULL)    {        forEachXmlChildElement ( (*pRoot), pChild)        {            if (pChild->hasTagName ("Bypass") )            {                String text = pChild->getAllSubText();                setParameter (MasterBypass, text.getFloatValue() );            }        }        delete pRoot;        UIUpdateFlag=true;//Request UI update    }}//==============================================================================// This creates new instances of the plugin..AudioProcessor* JUCE_CALLTYPE createPluginFilter(){    return new ParaphrasisAudioProcessor();}